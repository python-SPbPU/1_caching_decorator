## 1_caching_decorator
### Автор: Плужникова Юлия, студент группы 5130201/20002
### Описание
В данном репозитории реализован декоратор "cache_decorator", который позволяет кэшировать результаты выполнения произвольной функции с ограничением по глубине кэша. 
### Функциональность
- Поддержка нескольких функций: несколько функций в программе могут быть одновременно задекорированы;
- Ограничение глубины кэша: можно указать максимальное количество кэшированных значений (глубину кэша);
- Работа с позиционными и ключевыми аргументами: ключ для кэша формируется на основе аргументов функции, включая как позиционные, так и ключевые.
### Особенности реализации
1. Для хранения кэшированных результатов используется словарь cache, а ключом является кортеж аргументов функции.
2. Для отслеживания порядка добавления элементов используется список cache_order.
3. Если результат функции для данных аргументов уже в кэше, он возвращается без повторного вычисления.
4. Если кэш переполнен, удаляется самый старый элемент.
### Тестирование
Было проведено несколько тестов на проверку работы декоратора:
1. Тест №1 был направлен на проверку возврата значений из кэша и удаления старых значений при превышении глубины кэша.
```
@cache_decorator(2)
    def example_1 (a, b):
        return a + b

    print("--------------------------------- тест 1 -------------------------------------")
    print(example_1(2,5))        #вычислили и добавили в кэш
    print(example_1(2,5))        #взяли из кэша
    print(example_1(1, 3))       #вычислили и добавили в кэш
    print(example_1(10, 12))     #кэш переполнен -> удалили (2,5) и добавили в кэш
    print(example_1(2,5))        #кэш переполнен -> удалили (1,3) и добавили в кэш
```
Результат:
```
--------------------------------- тест 1 -------------------------------------
7
(Возвращаем значение 7 из кэша по ключу: (2, 5))
7
4
(Превышена глубина кэша. Удаляем из кэша самый старый элемент с ключом: (2, 5))
22
(Превышена глубина кэша. Удаляем из кэша самый старый элемент с ключом: (1, 3))
7
```
2. Тест №2 был направлен на проверку независимости кэшей при одновременном декорировании нескольких функций.
```
@cache_decorator(3)
    def example_2(a):
        return a * 2

    @cache_decorator(2)
    def example_2_1(a):
        return a ** 2

    print("--------------------------------- тест 2 -------------------------------------")
    print(example_2(4))
    print(example_2_1(4))
    print(example_2(4))
    print(example_2_1(4))
```
Результат:
```
--------------------------------- тест 2 -------------------------------------
8
16
(Возвращаем значение 8 из кэша по ключу: 4)
8
(Возвращаем значение 16 из кэша по ключу: 4)
16
```
3. Тест №3 был направлен на проверку кэширования при наличии ключевых аргументов.
```
@cache_decorator(3)
    def example_3(a, b, c=1):
        return (a + b) * c

    print("--------------------------------- тест 3 -------------------------------------")
    print(example_3(3,5, 2))
    print(example_3(3, 5))
    print(example_3(6, 3, 3))
    print(example_3(3, 5, 2))
    print(example_3(1,4))
```
Результат:
```
--------------------------------- тест 3 -------------------------------------
16
8
27
(Возвращаем значение 16 из кэша по ключу: (3, 5, 2))
16
(Превышена глубина кэша. Удаляем из кэша самый старый элемент с ключом: (3, 5, 2))
5
```
